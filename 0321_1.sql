/*
KB 알파코 시스템즈
팀장ㅇㅇㅇ
부장ㅇㅇㅇ
차장ㅇㅇㅇ
대리ㅇㅇㅇ

은행 인력관리 시스템 제안
IT인재 역량강화, 특정업무 역량강화, 기간별 순환보직, 업무커리어패스
범위는 자율적으로 논의

추상화(개념적 설계)
논리적 설계, 데이터모델링 <<여기 포커스
물리적 설계, 테이블 생성
개발

독창적인 아이디어 필요. 인력개발 포인트.
데이터 샘플 20개 내외. 샘플데이터 질은 평가생략
ux시뮬레이션 할 수 있는 ppt 이미지

고객수요와 무관한 논리.

조회/수정기능

HR-SCOTT 테이블
HR-SCOTT데이터 
LECTURE 집계 예시
LECTURE 테이블, 뷰 : 테이블 컬럼 설명 제약조건 예시 DATA TYPE
				  STUDENT STU_ID 수강생 ID   000000~999999 NUMBER(6,0
		  		  STU_INFO
		  		  STU_GROUP
		  		  STU_DETAIL
		  		  LECTURE
LECTURE와이어프레임

회사명 회차 검색 후 전체 대상으로 그룹 조회 가능		  
그림으로 그리면 됨. 한장으로 정리하는게 좋음
엑셀 왼쪽에 그림, 오른쪽 설명
*/


--레코드 집계함수
--GROUP BY : 레코드 그룹별 집계
--HAVING : 집계조건
SELECT SUM(SAL)
 FROM EMP;

SELECT SUM(E.SAL) AS SUM_OF_SAL  --SUM : 집계함수. 값을 받아 하나의 값으로 정리하는 함수
	 , AVG(E.SAL) AS AVG_OF_SAL
 FROM EMP E;



--DISTINCT
SELECT DISTINCT DEPTNO
 FROM EMP E;

SELECT DISTINCT E.DEPTNO
			, E.SAL
			, E.EMPNO
 FROM EMP E;

SELECT DISTINCT SAL
 FROM EMP;

SELECT SUM(DISTINCT E.SAL) AS SUM_OF_DISTINCT
	, SUM(ALL E.SAL) AS SUM_OF_ALL
	, SUM(E.SAL) AS NORMAL_SUM
 FROM EMP ;

SELECT MAX(SAL) AS MAX_SAL
	, MIN(SAL) AS MIN_SAL
	, ROUND (MAX(SAL) / MIN(SAL), 1) AS MAX_MIN_ 
 FROM EMP
 WHERE DEPTNO = 30;

SELECT COUNT(EMPNO)
	, COUNT(COMM)
 FROM EMP;

SELECT COUNT(*)
 FROM EMP
 WHERE DEPTNO = 30;

SELECT COUNT(DISTINCT SAL)
	, COUNT(ALL SAL)
	, COUNT(SAL)
 FROM EMP;

SELECT COUNT(ENAME) 
 FROM EMP
 --WHERE COMM IS NOT NULL; : 어떤 값이든 있는 사람. COMM값이 있는 사람
 WHERE NVL(COMM, 0) > 0; -- : COMM이 ㅣ0인 사람까지 고려해야함.
 
 
--부서별 UNION ALL 이용해서 집계 . 무식한 집계방법
SELECT AVG(SAL), '10' AS DNO
 FROM EMP
 WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL), '20' AS DNO
 FROM EMP
 WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL), '30' AS DNO
 FROM EMP
 WHERE DEPTNO = 30;

 
--GROUP BY : 스마트한 집계방법
SELECT DEPTNO
	, COUNT(SAL)
	, AVG(SAL)
	, MAX(SAL)
	, MIN(SAL)
	, SUM(SAL)
 FROM EMP
 GROUP BY DEPTNO
 ORDER BY DEPTNO;

 
 SELECT DEPTNO, JOB
	, COUNT(SAL)
	, AVG(SAL + NVL(COMM, 0)) AS AVG_PAY
	, MAX(SAL + NVL(COMM, 0)) AS MAX_PAY
	, MIN(SAL + NVL(COMM, 0)) AS MIN_PAY
	, SUM(SAL + NVL(COMM, 0)) AS SUM_PAY
 FROM EMP
 GROUP BY DEPTNO, JOB
 ORDER BY DEPTNO, JOB;
 
 
--JOIN : 테이블 정규화로 분할된 테이블 컬럼을 다시 합치는 작업
 
SELECT *
 FROM EMP, DEPT -- 잘못된 JOIN 사용
 ORDER BY EMPNO;

SELECT *
 FROM EMP E, DEPT D  -- 잘못된 JOIN 사용
 WHERE E.ENAME = 'SMITH'
 ORDER BY E.EMPNO;


--INNRT JOIN : 교집합 컬럼 연결
SELECT *
 FROM EMP, DEPT
 WHERE DEPTNO = DEPTNO          ----------------??
 ORDER BY EMPNO;

SELECT *
 FROM EMP, DEPT
 WHERE EMP.DEPTNO = DEPT.DEPTNO
 ORDER BY EMPNO;

SELECT *
 FROM EMP E JOIN DEPT D
 	ON E.DEPTNO = D.DEPTNO;

SELECT E.EMPNO
	, E.HIREDATE
	, D.DNAME
	, E.JOB
	, E.SAL
 FROM EMP E JOIN DEPT D
 	ON E.DEPTNO = D.DEPTNO; --ON키워드 뒤 값 비교

 
 SELECT *
  FROM EMP E JOIN DEPT D 
  	USING (DEPTNO);         --- USING 키워드 하나로 동일칼럼 비교

SELECT E.EMPNO
	-- , E.HIREDATE
	, TO_CHAR(E.HIREDATE, 'YYYY-MM-DD') AS HIRE_YMD
	, E.ENAME
	, D.DEPTNO
	, D.LOC 
 FROM EMP E
 	, DEPT D
 WHERE E.DEPTNO = D.DEPTNO
 ORDER BY D.DEPTNO, E.EMPNO;


SELECT E.EMPNO
	-- , E.HIREDATE
	, TO_CHAR(E.HIREDATE, 'YYYY-MM-DD') AS HIRE_YMD
	, E.ENAME
	, D.DEPTNO
	, D.LOC 
	, E.SAL
 FROM EMP E
 	, DEPT D
 WHERE E.DEPTNO = D.DEPTNO AND E.SAL < 2000
 ORDER BY E.SAL DESC;


SELECT D.DNAME AS DNAME, E.JOB AS JOB
	, ROUND(AVG(E.SAL), 0) AS AVG_SAL
	, SUM(E.SAL) AS SUM_SAL
	,MAX(E.SAL) AS MAX_SAL
	,MIN(E.SAL) AS MIN_SAL
	,COUNT(E.SAL) AS CNT_SAL
 FROM EMP E
 	, DEPT D
 WHERE E.DEPTNO = D.DEPTNO AND E.SAL < 2000
 GROUP BY D.DNAME, E.JOB ;


--1단계 전체자료 출력
SELECT *
 FROM EMP e, SALGRADE s
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
--2단계 필요한자료만 출력
SELECT E.ENAME
	, S.GRADE
	, E.DEPTNO
	, E.SAL
	, E.JOB
	, E.HIREDATE
 FROM EMP e, SALGRADE s
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;


SELECT E.ENAME
	, E.DEPTNO
	, E.JOB
	, S.GRADE
	, E.SAL
	, S.LOSAL AS LOW_RNG
	, S.HISAL AS HIGH_RNG
 FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

SELECT S.GRADE
	, COUNT(E.ENAME) AS EMP_CNT	 --임직원 수 집계
 FROM EMP E, SALGRADE S
 WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
 GROUP BY S.GRADE       -- GRADE 기준으로 그룹
 ORDER BY EMP_CNT DESC ;   -- 임직원수가 많은 순으로


 SELECT *
  FROM EMP E, DEPT D  ---내가 필요한 테이블 별칭 지정
  WHERE E.DEPTNO = D.DEPTNO;  --INNER JOIN


  
  
--193P
--SELF-JOIN : 자기 자신의 릴레이션을 이용해서 테이블 컬럼 조작

--1단계. 체계구성
SELECT
 FROM EMP e1, EMP e2  -- SELF-JOIN목적
 WHERE E1.EMPNO = E2.MGR
 
--2단계. 어떤 컬럼 사용햐는지 지정
SELECT E1.EMPNO AS EMP_NO
	, E1.ENAME AS EMP_NAME
	, E2.MGR AS MGR_NO
	, E2.ENAME AS MGR_NAME
 FROM EMP e1, EMP e2
 WHERE E1.EMPNO = E2.MGR;

SELECT E1.EMPNO AS EMP_NO
	, E1.ENAME AS EMP_NAME
	, E1.MGR AS MGR_NO_E1
	, E2.ENAME AS MGR_NAME
 FROM EMP e1, EMP e2
 WHERE E1.EMPNO = E2.MGR;
  
SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E2.EMPNO AS MGR_NO
	, E2.ENAME AS MGR_NAME
 FROM EMP E1, EMP e2
 WHERE E1.MGR = E2.EMPNO;


--LEFT-JOIN : 왼쪽 테이블 값을 모두 가져오고, JOIN하는 테이블에서 해당되는 값 일부만 가져오기
SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E2.EMPNO AS MGR_NO
	, E2.ENAME AS MGR_NAME
 FROM EMP E1, EMP E2
 WHERE E1.MGR = E2.EMPNO(+)
 
 --표준SQL을 활용하여 매니저, 담당직원 정보 출력
 SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E2.EMPNO AS MGR_NO
	, E2.ENAME AS MGR_NAME
  FROM EMP E1 LEFT OUTER JOIN EMP E2
  	ON E1.MGR = E2.EMPNO;
 
  	
--RIGHT-JOIN : 오라클 SQL 활용
SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E2.EMPNO AS MGR_NO
	, E2.ENAME AS MGR_NAME
 FROM EMP E1, EMP E2
 WHERE E1.MGR (+) = E2.EMPNO
 
 --표준SQL
 SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E2.EMPNO AS MGR_NO
	, E2.ENAME AS MGR_NAME
 FROM EMP E1 RIGHT OUTER JOIN EMP E2
 	ON E1.MGR = E2.EMPNO;
  	
--FULL
SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E2.EMPNO AS MGR_NO
	, E2.ENAME AS MGR_NAME
 FROM EMP E1 FULL OUTER JOIN EMP E2
 	ON E1.MGR = E2.EMPNO;  	
 	
SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E2.EMPNO AS MGR_NO
	, E2.ENAME AS MGR_NAME
 FROM EMP E1 FULL OUTER JOIN EMP E2
 	ON E1.MGR = E2.EMPNO;
  	
  	
------------------------------------------------------------------
--201P
SELECT D.DEPTNO
	, D.DNAME
	, E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E1.SAL
	, S.LOSAL
	, S.HISAL
	, S.GRADE
	, E2.EMPNO AS MGR_EMPNO
	, E2.ENAME AS MGR_ENAME
 FROM EMP E1
 	, DEPT D
 	, SALGRADE S
 	, EMP E2
 WHERE E1.EMPNO(+) = D.DEPTNO
  AND E1.SAL BETWEEN S.LOSAL AND S.HISAL
  AND E1.MGR = E2.EMPNO;
 
--일부분 떼서 테이블 생성해보기
/*	  D.DEPTNO
	, D.DNAME
	, E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E1.SAL
	
*/	
SELECT D.DEPTNO
	, D.DNAME
	, E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E1.SAL
	, S.LOSAL
	, S.HISAL
	, S.GRADE
	, E2.EMPNO AS MGR_EMPNO
	, E2.ENAME AS MGR_ENAME
 FROM EMP E1
 	, DEPT D
 	, SALGRADE S
 	, EMP E2
 WHERE E1.EMPNO(+) = D.DEPTNO
  AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
  AND E1.MGR = E2.EMPNO;
 
--D,E1 
SELECT D.DEPTNO
	, D.DNAME
	, E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E1.SAL
 FROM EMP E1, DEPT D
 WHERE E1.DEPTNO(+) = D.DEPTNO;
	
--E1,S	
SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E1.SAL
	, S.LOSAL
	, S.HISAL
	, S.GRADE
 FROM EMP E1, SALGRADE S
 --WHERE E1.SAL BETWEEN S.LOSAL AND S.HISAL
 WHERE E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
 --WHERE E1.SAL BETWEEN S.LOSAL AND S.HISAL
 
--E1,E2
 SELECT E1.EMPNO
	, E1.ENAME
	, E1.MGR
	, E1.SAL
	, E2.EMPNO AS MGR_EMPNO
	, E2.ENAME AS MGR_ENAME
 FROM EMP E1
 	, EMP E2
 WHERE E1.MGR = E2.EMPNO;
 
--표준 SQL 출력
--EMP E1, DEPT D, SALGRADE

SELECT d.DEPTNO
	, d.DNAME
	, e1.EMPNO
	, e1.ENAME
	, e1.MGR
	, e1.SAL
	, s.LOSAL
	, s.HISAL
	, s.GRADE
	, e2.EMPNO AS MGR_EMPNO
	, e2.ENAME AS MGR_ENAME
 FROM EMP e1 
 	RIGHT JOIN DEPT d
 	ON e1.DEPTNO = d.DEPTNO
 	LEFT OUTER JOIN SALGRADE s
 	ON (e1.SAL) >= s.LOSAL AND e1.SAL <= s.HISAL
 	LEFT OUTER JOIN EMP e2
 	ON (e1.MGR = e2.EMPNO);
 	
 
-- 단일행 서브쿼리 - 쿼리안에 쿼리 문장 
--
 SELECT sal
  FROM EMP
  WHERE ENAME = 'SMITH';
 
 SELECT *
  FROM EMP e, DEPT d
  WHERE e.DEPTNO = d.DEPTNO 
 	AND e.DEPTNO = 20
  	AND e.SAL > (SELECT AVG(sal) FROM EMP);

SELECT AVG(sal) FROM EMP; 
  
--204p
--다중행 서브쿼리
-- 2개 이상의 값으로 된 테이블
SELECT *
 FROM EMP
 WHERE SAL
 	IN (SELECT AVG(SAL)) -----------------------?
 
 
 	
SELECT DEPTNO, MAX(SAL)
 FROM EMP
 GROUP BY DEPTNO
 ORDER BY DEPTNO;
 	
SELECT *
 FROM EMP
 WHERE SAL < ANY( SELECT sal FROM emp WHERE DEPTNO = 30); --30번 부서에 있는 사람과 비교
 
 SELECT *
 FROM EMP
 WHERE SAL < All( SELECT sal FROM emp WHERE DEPTNO = 30);
 
SELECT DEPTNO, SAL
 FROM EMP
 WHERE DEPTNO = 30;

SELECT min(sal), max(sal)
 FROM EMP
 WHERE DEPTNO = 30;

--다중열 서브 쿼리
--서브쿼리 결과가 두 개 이상의 컬럼으로 구성된 테이블 값
SELECT *
 FROM EMP
 WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, max(sal) FROM emp GROUP BY DEPTNO);

SELECT DEPTNO, SAL, EMPNO, ENAME
 FROM EMP
 WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, max(sal) FROM emp GROUP BY DEPTNO);

--FROM절에 사용되는 서브쿼리
SELECT 
 FROM (SELECT FROM ) A
    , (SELECT FROM ) B
 WHERE A. = B.
 
 SELECT a.empno
 	, A.sal
 	, B.dname
 	, B.loc
 FROM (SELECT * FROM emp WHERE deptno = 30) A
    , (SELECT * FROM dept) B
 WHERE A.deptno = B.deptno;
 

-- with절 사용 - 편리한 가상테이블로 활용
WITH E AS ()
	, D AS ()
SELECT ...
 FROM E, D

WITH E AS (SELECT * FROM emp WHERE deptno = 20)
	, D AS (SELECT * FROM dept)
	, S AS (SELECT * FROM salgrade)
SELECT E.ename
	, D.dname
	, D.loc
	, S.grade
 FROM E, D, S
 WHERE E.deptno = D.deptno
 	AND E.sal BETWEEN S.losal AND S.hisal;
 	
 
 
 --CREATE table
 
 CREATE TABLE dept_temp
  AS SELECT * FROM dept;

--DML : SELECT(원하는 데이터 반환) / INSERT/DELETE/UPDATE
--DDL : CREATE/ALTER/DROP(테이블 자체를 삭제. 완전히 삭제)

--COMMIT;